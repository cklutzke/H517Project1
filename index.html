<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>ckixd - Cholera</title>
	<link type="text/css" rel="stylesheet" href="cholera.css"/>
	<script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
	<style>
		svg .street {
			stroke: gray;
			stroke-width: 1px;
			fill: none;
		}
		
		svg .mapLabel {
			font-family: sans-serif;
			fill: gray;
		}
		
		svg .pump {
			fill: black;
			stroke: none;
			r: 4;
		}
		
		svg .death {
			fill: red;
			stroke: none;
			r: 2;
		}
		
		svg .graphline {
			fill: none;
			stroke-width: 1px;
		}
		
		svg .deathhoverbar:hover {
			fill-opacity: .1;
		}
		
		.axis path,
		.axis line {
			fill: none;
			stroke: gray;
			shape-rendering: crispEdges;
		}

		.axis text {
			font-family: sans-serif;
			font-size: 10px;
			fill: gray;
		}
		
	</style>
</head>
<body>
	<div class="pagetitle" style="float: left;">Cholera Outbreak: London, 1854</div>
	<!--<div class="pagebutton" style="float: right; width: 100px; height: 30px;">About-->
	<div style="float: right;">
		<form>
			<input class="pagebutton" type="button" value="About"
			onclick="window.location.href='about.html'" />
		</form>
	</div>
	<br/>
	<div class="pagetext">
		<p>
		In 1854, an outbreak of cholera in the Soho district of London killed 616 people. Physician
		John Snow theorized that the disease was related to contaminated water.
		He created a map that showed where the deaths occurred in relation to water pumps in the area 
		(the black dots), and showed they were strongly correlated with a water pump at Broad
		Street and Cambridge street. This data visualization is inspired by his work.
		</p>
	</div>
	<svg id="map" width="500px" height="500px">
	</svg>
	<svg id="graph" width="500px" height="500px">
		<text id='label' x='5' y='20'>Deaths per day</text>
	</svg>

	
	<script type="text/javascript">
	
		// TODO: Can I make the size of the SVGs responsive?
		// NOTE: parseInt strips off "px", but won't work if the size is set by percentage.
	
		let map = d3.select("svg#map");
		let mapWidth = parseInt(map.style("width"));
		let mapHeight = parseInt(map.style("height"));
		let mapXScale = d3.scale.linear();
		let mapYScale = d3.scale.linear();
		
		let graph = d3.select("svg#graph");
		let graphWidth = parseInt(graph.style("width"));
		let graphHeight = parseInt(graph.style("height")) - 50;
		let graphXScale = d3.scale.linear();
		let graphYScale = d3.scale.linear();
		let padding = 30;
		
		let ageRange = ["0-10","11-20","21-40","41-60","61-80","> 80"]
		
		let streets = [];
		let mapLabels = [];
		let pumps = [];
		
		let deathDays = [];
		let deaths = [];
		let maxDeaths = 0;
		
		// Draw the location of each death on the map.
		// TODO: Consider using squares or crosses to mark deaths.
		function drawDeathsMap() {
			map.selectAll('.death')
				.data(deaths)
				.enter()
				.append('circle')
				.attr('id', function(d,i) { return "death" + i; })
				.attr('class', function(d) {
					return "death " +
						d.gender + " " +
						"deathday" + d.deathday;
				})
				.attr('cx', function(d) { return mapXScale(d.x); })
				.attr('cy', function(d) { return mapYScale(d.y); })
				.append("title")
				.text(function(d) {
					return d.gender + "\r\n" +
						"age " + ageRange[d.ageRange] + "\r\n" +
						"died " + d.deathdate;
				});
		}
		
		// Draw the graph lines according to the current settings.
		function drawDeathsGraphLines() {
			let graphTotalPathGenerator = d3.svg.line()
				.x(function(d) { return graphXScale(d.day); })
				.y(function(d) { return graphYScale(d.total); });

			graph.append('path')
				.attr('class', 'graphline')
				.style('stroke', 'red')
				.attr('d', graphTotalPathGenerator(deathDays));
				
			let graphMalePathGenerator = d3.svg.line()
				.x(function(d) { return graphXScale(d.day); })
				.y(function(d) { return graphYScale(d.male); });

			graph.append('path')
				.attr('class', 'graphline')
				.style('stroke', 'blue')
				.attr('d', graphMalePathGenerator(deathDays));

			let graphFemalePathGenerator = d3.svg.line()
				.x(function(d) { return graphXScale(d.day); })
				.y(function(d) { return graphYScale(d.female); });

			graph.append('path')
				.attr('class', 'graphline')
				.style('stroke', 'orange')
				.attr('d', graphFemalePathGenerator(deathDays));

		}
		
		// Draw the overall structure of the graph.
		function drawDeathsGraph() {

			// Create hover bars
			// TODO: CENTER the hoverbars over each point.
			let graphXScaleBand = d3.scale.ordinal()
				.domain(d3.range(deathDays.length))
				.rangeBands([padding, graphWidth - padding], 0);

			graph.selectAll("rect.deathhoverbar")
				.data(deathDays)
				.enter()
				.append("rect")
				.attr("x", function(d, i) {
					return graphXScaleBand(i);
				})
				.attr("y", padding)
				.attr("width", graphXScaleBand.rangeBand())
				.attr("height", graphHeight - padding * 2)
				.attr("fill", "black")
				.attr("fill-opacity", "0")
				.attr("stroke", "none")
				.attr("stroke-width", "0")
				.attr("id", function(d) { return d.deathdate; })
				.attr("class", "deathhoverbar")
				.on("mouseover", function(d) {
					// Seems like D3 should provide a filter for this, but
					// who has time to figure that out?
					for (let i=deathDays.length-1;i > d.day;i--) {
						map.selectAll(".deathday" + i).attr("visibility","hidden");
					}
				})
				.on("mouseout", function(d) {
					map.selectAll(".death").attr("visibility","visible");
				})
				.append("title")
				.text(function(d) {
					return d.deathdate + ": " + d.total + 
						(d.total==1 ? " death" : " deaths");
				});
				
				// Draw the axes.
				// TODO: Label the X axis by date, not # of days.
				let xAxis = d3.svg.axis()
					.scale(graphXScale)
					.orient('bottom')

				let yAxis = d3.svg.axis()
					.scale(graphYScale)
					.orient('left');

				graph.append('g')
					.attr('class', 'axis')
					.attr('transform', 'translate(0,' + (graphHeight - padding) + ')')
					.call(xAxis);

				graph.append('g')
					.attr('class', 'axis')
					.attr('transform', 'translate(' + padding + ',0)')
					.call(yAxis);
		}		
		
		// Load the death data and add it to the map and the graph.
		function loadDeaths() {
		
			// Load the coordinates and demographics for each death. These are
			// assumed to be provided in the order in which the victim died, for
			// purposes of correlating to deathdays.csv.
			d3.csv("deaths_age_sex.csv", function(data) {
				for (let i=0; i < data.length; i++) {
					deaths.push(
						{
							x: data[i].x,
							y: data[i].y,
							ageRange: +data[i].age,
							gender: +data[i].gender==1 ? "female" : "male"
						}
					);
				}
				
				// Load the number of deaths for each date, and update
				// each death record with the day and date on which it occurred.
				d3.csv("deathdays.csv", function(data) {
					let deathId = 0;
					for (let day = 0; day < data.length; day++) {
					
						let totalCount = +data[day].deaths;
						let maleCount = 0;
						let femaleCount = 0;
						
						// Find the death with the greatest number of days, to set the vertical scale.
						if (maxDeaths < totalCount) {
							maxDeaths = totalCount;
						}
						
						for (let i=0; i < totalCount; i++) {
							// Update the individual death records with the day and date of death.
							deaths[deathId].deathday = day;
							deaths[deathId].deathdate = data[day].date;
							
							// Count the deaths on each deathDay by demographic.
							if (deaths[deathId].gender == "male") {
								maleCount++;
							} else {
								femaleCount++;
							}
							
							// Increment to the next individual death record.
							deathId++;
						}
						
						deathDays.push ({
							day: day,
							deathdate: data[day].date,
							total: totalCount,
							male: maleCount,
							female: femaleCount
						});
						
					}

					graphXScale.domain([0, deathDays.length-1]).range([padding, graphWidth - padding]);
					graphYScale.domain([0, maxDeaths]).range([graphHeight - padding, padding]);
					
					drawDeathsMap();
					drawDeathsGraphLines();
					drawDeathsGraph();
				});
				
			});
		}

		// Load and draw the water pumps.
		function drawPumps() {
			d3.csv("pumps.csv", function(data) {
				for (let i=0; i < data.length; i++) {
					pumps.push(
						{x: data[i].x, y: data[i].y}
					);
				}
				
				map.selectAll('.pump')
					.data(pumps)
					.enter()
					.append('circle')
					.attr('class', 'pump')
					.attr('cx', function(d) { return mapXScale(d.x); })
					.attr('cy', function(d) { return mapYScale(d.y); });
					
			});
		}
		
		// Load and draw the street and building labels.
		function drawMapLabels() {
			d3.csv("maplabels.csv", function(data) {
				for (let i=0; i < data.length; i++) {
					mapLabels.push({
						x: data[i].x,
						y: data[i].y,
						text: data[i].text,
						fontsize: data[i].fontsize,
						angle: data[i].angle
					});
				}
				
				map.selectAll('.mapLabel')
					.data(mapLabels)
					.enter()
					.append('text')
					.attr('class', 'mapLabel')
					.attr('x', function(d) { return d.x; })
					.attr('y', function(d) { return d.y; })
					.attr('font-size', function(d) { return d.fontsize; })
					.text(function(d) { return d.text; })
					.attr('transform', function(d) {
						return 'rotate(' + d.angle + ',' +
							d.x + ',' + d.y + ')';
					});
					
				/*
				// We used this code to estimate coordinates
				// for all the labels.
				map.on("click", function() {
					console.dir(event.clientX + ", " + event.clientY);
				});
				*/
			});
		}
		
		// Provide a means of drawing the map lines at scale.
		let lineFunction = d3.svg.line()
			.x(function(d) { return mapXScale(d.x); })
			.y(function(d) { return mapYScale(d.y); })
			.interpolate("linear");
		
		// Start the process by loading and drawing the map.
		d3.json("streets.json", function(data) {
			streets = data;
		
			// TODO: Scale the map to fill its SVG space.
			mapXScale.domain([3,20]).range([0, mapWidth]);
			mapYScale.domain([3,20]).range([mapHeight, 0]);
			
			for (let i=0; i < streets.length; i++) {
				map.append("path")
					.attr("d", lineFunction(streets[i]))
					.attr("class", "street");
			}
			
			drawMapLabels();
			drawPumps();
			loadDeaths();
		});
				
	</script>
</body>


</html>
