<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>H517 - Project 1</title>
	<script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
	<style>
		svg .street {
			stroke: gray;
			stroke-width: 1px;
			fill: none;
		}
		
		svg .pump {
			fill: black;
			stroke: none;
			r: 5;
		}
		
		svg .death {
			stroke: none;
			r: 2;
		}
		
		svg .male {
			fill: blue;
		}
		
		svg .female {
			fill: red;
		}
		
		svg .deathhoverbar:hover {
			fill-opacity: .1;
		}
		
	</style>
</head>
<body>

	<svg id="map" width="500px" height="500px">
		<rect id="mapBorder" x="0" y="0" width="500" height="500" stroke-width="1" stroke="black" fill="none"/>
	</svg>
	<svg id="graph" width="600px" height="400px">
		<rect id="graphBorder" x="0" y="0" width="600" height="400" stroke-width="1" stroke="black" fill="none"/>
		<text id='label' x='20' y='20'>Deaths per day</text>
	</svg>

	
	<script type="text/javascript">
	
		// TODO: Can I make the size of the SVGs responsive?
		// NOTE: parseInt strips off "px", but won't work if the size is set by percentage.
	
		let map = d3.select("svg#map");
		let mapWidth = parseInt(map.style("width"));
		let mapHeight = parseInt(map.style("height"));
		let mapXScale = d3.scale.linear();
		let mapYScale = d3.scale.linear();
		
		let graph = d3.select("svg#graph");
		let graphWidth = parseInt(graph.style("width"));
		let graphHeight = parseInt(graph.style("height"));
		let graphXScale = d3.scale.linear();
		let graphYScale = d3.scale.linear();
		
		let streets = [];
		let pumps = [];
		
		let deathDays = [];
		let deaths = [];
		let maxDeaths = 0;
		
		// Load the death data and add it to the map and the graph.
		function drawDeaths() {
		
			// Load the coordinates and demographics for each death. These are
			// assumed to be provided in the order in which the victim died, for
			// purposes of correlating to deathdays.csv.
			d3.csv("deaths_age_sex.csv", function(data) {
				for (let i=0; i < data.length; i++) {
					deaths.push(
						{
							x: data[i].x,
							y: data[i].y,
							ageRange: data[i].age,
							gender: +data[i].gender==1 ? "female" : "male"
						}
					);
				}
				
				// Load the number of deaths for each date, and update
				// each death record with the day and date on which it occurred.
				d3.csv("deathdays.csv", function(data) {
					let deathId = 0;
					for (let day = 0; day < data.length; day++) {
					
						let deathCount = +data[day].deaths;
						
						deathDays.push ({
							day: day,
							deathdate: data[day].date,
							count: deathCount
						});
						
						if (maxDeaths < deathCount) {
							maxDeaths = deathCount;
						}
						
						for (let i=0; i < deathCount; i++) {
							deaths[deathId].deathday = day;
							deaths[deathId].deathdate = data[day].date;
							deathId++;
						}
					}
				
					// Draw each death on the map.
					map.selectAll('.death')
						.data(deaths)
						.enter()
						.append('circle')
						.attr('id', function(d,i) { return "death" + i; })
						.attr('class', function(d) {
							return "death " +
								d.gender + " " +
								"deathday" + d.deathday;
						})
						.attr('cx', function(d) { return mapXScale(d.x); })
						.attr('cy', function(d) { return mapYScale(d.y); });
						
					// TODO: Draw axes on the graph.
					
					// Draw the deaths on the graph.
					graphXScale.domain([0, data.length-1]).range([0, graphWidth]);
					graphYScale.domain([0, maxDeaths]).range([graphHeight, 0]);

					let graphPathGenerator = d3.svg.line()
						.x(function(d) { return graphXScale(d.day); })
						.y(function(d) { return graphYScale(d.count); });

					graph.append('path')
						.style('fill', 'none')
						.style('stroke', 'steelblue')
						.style('stroke-width', '3px')
						.attr('d', graphPathGenerator(deathDays));
						
					// Create hover bars
					// TODO: Center the hoverbars over each point.
					let graphXScaleBand = d3.scale.ordinal()
						.domain(d3.range(data.length))
						.rangeBands([0, graphWidth], 0);

					graph.selectAll("rect.deathhoverbar")
						.data(deathDays)
						.enter()
						.append("rect")
						.attr("x", function(d, i) {
							return graphXScaleBand(i);
						})
						.attr("y", 0)
						.attr("width", graphXScaleBand.rangeBand())
						.attr("height", graphHeight)
						.attr("fill", "black")
						.attr("fill-opacity", "0")
						.attr("stroke", "none")
						.attr("stroke-width", "0")
						.attr("id", function(d) { return d.deathdate; })
						.attr("class", "deathhoverbar")
						.on("click", function(d) {
							map.selectAll(".death").attr("fill-opacity",".1");
							map.selectAll(".deathday" + d.day).attr("fill-opacity","1");
							console.dir(d);
						});
						
	/*
			var xAxis = d3.svg.axis()
    			.scale(xScale)
    			.orient('bottom')
    			.tickFormat(function(d) { return "" + d; })

    		var yAxis = d3.svg.axis()
    			.scale(yScale)
    			.orient('left');


    		g.append('g')
    			.attr('class', 'axis')
    			.attr('transform', 'translate(0,' + CHART_HEIGHT + ')')
    			.call(xAxis);

    		g.append('g')
    			.attr('class', 'axis')
    			.call(yAxis);

*/
					
					
				});
				
			});
		}

		// Load and draw the water pumps.
		function drawPumps() {
			d3.csv("pumps.csv", function(data) {
				for (let i=0; i < data.length; i++) {
					pumps.push(
						{x: data[i].x, y: data[i].y}
					);
				}
				
				map.selectAll('.pump')
					.data(pumps)
					.enter()
					.append('circle')
					.attr('class', 'pump')
					.attr('cx', function(d) { return mapXScale(d.x); })
					.attr('cy', function(d) { return mapYScale(d.y); });
					
			});
		}
		
		// Provide a means of drawing the map lines at scale.
		let lineFunction = d3.svg.line()
			.x(function(d) { return mapXScale(d.x); })
			.y(function(d) { return mapYScale(d.y); })
			.interpolate("linear");
		
		// Start the process by loading and drawing the map.
		d3.json("streets.json", function(data) {
			streets = data;
		
			// TODO: Scale the map to fill its SVG space.
			mapXScale.domain([0,20]).range([0, mapWidth]);
			mapYScale.domain([0,20]).range([mapHeight, 0]);
			
			for (let i=0; i < streets.length; i++) {
				map.append("path")
					.attr("d", lineFunction(streets[i]))
					.attr("class", "street");
			}
			
			drawPumps();
			drawDeaths();
		});
		
				
	</script>
</body>


</html>
